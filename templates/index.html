<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>USW00012918 — Daily Temperatures (°F)</title>

  <!-- Local Plotly bundle staged by app.py -->
  <script src="{{ url_for('static', filename='vendor/plotly/plotly.min.js') }}" charset="utf-8"></script>

  <!-- Local Grid.js bundle staged by app.py -->
  <link href="{{ url_for('static', filename='vendor/gridjs/mermaid.min.css') }}" rel="stylesheet" />
  <script src="{{ url_for('static', filename='vendor/gridjs/gridjs.umd.js') }}"></script>

  <style>
    :root { color-scheme: light dark; }
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; line-height: 1.35; }
    header, footer, section { padding: 0.75rem 1rem; }
    #chart { width: 100%; height: 80vh; max-height: 1000px; }
    #ridge { width: 100%; height: 72vh; max-height: 900px; }
    h2 { margin: 0.5rem 0 0.25rem; }
    .note { font-size: 0.9rem; opacity: 0.85; }
    .divider {
      height: 1px;
      background: #ccc; /* Fallback for older browsers */
      background: color-mix(in lch, CanvasText 20%, Canvas 80%);
      margin: 0.75rem 0;
      opacity: 0.3;
    }

    /* Summary controls & table */
    .summary-wrap { padding: 0.75rem 1rem 1.25rem; }
    .summary-controls { display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; margin-bottom: 0.5rem; }
    .summary-controls .group { display: flex; align-items: center; gap: 0.5rem; }
    .summary-controls label { font-size: 0.95rem; }
    .summary-controls .metric label { margin-right: 0.75rem; }
    .summary-controls input[type="number"] { width: 6rem; padding: 0.25rem 0.4rem; }
    .summary-actions { margin-left: auto; display: flex; gap: 0.5rem; }
    #summary-grid { width: 100%; }
  </style>
</head>



<body>
  <header>
    <h1 style="margin:0.25rem 0;">USW00012918 — Daily Max/Min Temperature (°F)</h1>
      <div class="note">
        CSV columns: DATE, TMAX, TMIN (°F). Missing values appear as gaps.
      </div>
  </header>

  <!-- Chart 1: Daily TMAX/TMIN time-series (default view ≥ 2020-01-01) -->
  <main>
    <div id="chart"></div>

    <div class="divider"></div>

    <!-- Chart 2: Ridgeline by Year (2020–2025) -->
    <section>
      <h2>Ridgeline — Daily Mean Temperature by Day‑of‑Year (2020–2025)</h2>
      <div class="note">
        Canonical DOY axis (1–366). Non‑leap years have <code>null</code> at DOY 60 (Feb 29) so unified hover lines up across years.
        Gaps are shown explicitly (no fill painted over missing data).
      </div>
      <div id="ridge"></div>
    </section>

    <div class="divider"></div>

    <!-- Summary Table (Grid.js) -->
    <section class="summary-wrap">
      <h2>Monthly Summary by Year</h2>
      <div class="note">Select a metric and year range; months are fixed Jan–Dec. Values are °F (1 decimal). “Record” means within that year &amp; month.</div>

      <div class="summary-controls">
        <div class="group metric">
          <label><strong>Metric:</strong></label>
          <label><input type="radio" name="metric" value="avg_tmax" checked> Avg TMAX</label>
          <label><input type="radio" name="metric" value="avg_tmin"> Avg TMIN</label>
          <label><input type="radio" name="metric" value="rec_tmax"> Record TMAX</label>
          <label><input type="radio" name="metric" value="rec_tmin"> Record TMIN</label>
        </div>

        <div class="group">
          <label for="yearStart"><strong>Years:</strong></label>
          <input id="yearStart" type="number" value="2020" step="1">
          <span>to</span>
          <input id="yearEnd" type="number" value="2025" step="1">
        </div>

        <div class="summary-actions">
          <button id="btnApply">Apply</button>
          <button id="btnDownload">Download CSV</button>
        </div>
      </div>

      <div id="summary-grid"></div>
    </section>
  </main>

  <footer class="note">
    Default view for the top chart: ≥ Jan 1, 2020. Use the range slider to navigate; buttons set the view to Default or All.
  </footer>

  <script>
    // -------- Helpers for charts --------
    function hexToRgba(hex, alpha) {
      const h = hex.replace('#', '');
      const int = parseInt(h, 16);
      const r = (int >> 16) & 255, g = (int >> 8) & 255, b = int & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }
    function ordinal(n) {
      const s = ["th","st","nd","rd"], v = n % 100;
      return s[(v - 20) % 10] || s[v] || s[0];
    }
    function formatDateOrdinal(iso) {
      const d = new Date(iso + "T00:00:00Z");
      const month = d.toLocaleString("en-US", { timeZone: "UTC", month: "long" });
      const day = d.getUTCDate();
      const year = d.getUTCFullYear();
      return `${month} ${day}${ordinal(day)} ${year}`;
    }
    function dayOfYearISO(isoDate) {
      const dt = new Date(isoDate + "T00:00:00Z");
      const start = new Date(Date.UTC(dt.getUTCFullYear(), 0, 1));
      return Math.floor((dt - start) / 86400000) + 1;
    }
    function isoFromYearAndDoy(year, doy) {
      const start = new Date(Date.UTC(year, 0, 1));
      start.setUTCDate(start.getUTCDate() + (doy - 1));
      return start.toISOString().slice(0, 10);
    }
    function isLeap(year) {
      return (year % 4 === 0) && (year % 100 !== 0 || year % 400 === 0);
    }
    function meanF(tmax, tmin) {
      const hasMax = (tmax !== null && tmax !== undefined);
      const hasMin = (tmin !== null && tmin !== undefined);
      if (hasMax && hasMin) return Number(((tmax + tmin) / 2).toFixed(1));
      if (hasMax) return tmax;
      if (hasMin) return tmin;
      return null;
    }
    const MONTH_TICKS = [1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
    const MONTH_TEXT  = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    async function loadData() {
      const resp = await fetch("/api/weather", { cache: "no-store" });
      if (!resp.ok) throw new Error(`Failed to load data (${resp.status})`);
      return resp.json();
    }

    loadData().then(data => {
      // ---------- Chart 1 ----------
      if (!data || !Array.isArray(data.dates) || data.dates.length === 0) {
        document.getElementById("chart").innerHTML = `<div style="padding:1rem;">No data available.</div>`;
        return;
      }

      const minDate = data.dates[0];
      const maxDate = data.dates[data.dates.length - 1];
      const DEFAULT_START = "2020-01-01";
      const startCandidate = (maxDate >= DEFAULT_START) ? DEFAULT_START : minDate;
      const initialStart = (minDate > startCandidate) ? minDate : startCandidate;

      const hoverDates = data.dates.map(formatDateOrdinal);

      const traceMax = {
        type: "scattergl", mode: "lines", name: "TMAX (°F)",
        x: data.dates, y: data.tmax, customdata: hoverDates,
        line: { color: "#d62728", width: 1.5 }, connectgaps: false,
        hovertemplate: "%{customdata}<br>TMAX: %{y:.1f}°F<extra></extra>"
      };
      const traceMin = {
        type: "scattergl", mode: "lines", name: "TMIN (°F)",
        x: data.dates, y: data.tmin, customdata: hoverDates,
        line: { color: "#1f77b4", width: 1.5 }, connectgaps: false,
        hovertemplate: "%{customdata}<br>TMIN: %{y:.1f}°F<extra></extra>"
      };

      const layout1 = {
        uirevision: "keep",
        title: { text: "USW00012918 — Daily Max/Min Temperature (°F)", x: 0, xanchor: "left" },
        legend: { orientation: "h", x: 1, y: 1.15, xanchor: "right", yanchor: "bottom" },
        margin: { t: 60, r: 20, b: 60, l: 60 },
        xaxis: {
          type: "date", title: "Date", autorange: false,
          range: [initialStart, maxDate],
          rangeslider: { visible: true, range: [minDate, maxDate] }
        },
        yaxis: { title: "Temperature (°F)", tickformat: ".1f", ticksuffix: "°F", zeroline: false },
        hovermode: "x unified",
        updatemenus: [{
          type: "buttons", direction: "right",
          x: 0, y: 1.22, xanchor: "left", yanchor: "bottom",
          pad: { r: 6, t: 0, b: 0, l: 0 }, showactive: false,
          buttons: [
            { label: "Default", method: "relayout", args: [ { "xaxis.range": [initialStart, maxDate] } ] },
            { label: "All",     method: "relayout", args: [ { "xaxis.range": [minDate,    maxDate] } ] }
          ]
        }]
      };

      Plotly.newPlot("chart", [traceMax, traceMin], layout1, { responsive: true, displaylogo: false });

      // ---------- Chart 2: Ridgeline ----------
      buildRidgelineCanonical(data);
    }).catch(err => {
      document.getElementById("chart").innerHTML =
        `<div style="padding:1rem;color:crimson">
           <strong>Error:</strong> ${String(err.message || err)}<br/>
           Make sure the Flask app is running at <code>http://localhost:5003</code>.
         </div>`;
    });

    function buildRidgelineCanonical(data) {
      const YEARS  = [2020, 2021, 2022, 2023, 2024, 2025];
      const COLORS = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b'];
      const DOY = Array.from({ length: 366 }, (_, i) => i + 1);

      function yearSeries(year) {
        const yVals = new Array(366).fill(null);
        const hover = new Array(366).fill(null);
        for (let i = 0; i < data.dates.length; i++) {
          const ds = data.dates[i];
          const y  = Number(ds.slice(0, 4));
          if (y !== year) continue;

          const tmax = data.tmax[i];
          const tmin = data.tmin[i];
          const tm = (tmax !== null && tmin !== null) ? Number(((tmax + tmin) / 2).toFixed(1))
                    : (tmax !== null ? tmax : (tmin !== null ? tmin : null));
          if (tm === null) continue;

          const natDOY = dayOfYearISO(ds);
          const cDOY = ( (year % 4 === 0) && (year % 100 !== 0 || year % 400 === 0) ) ? natDOY : (natDOY >= 60 ? natDOY + 1 : natDOY);
          if (cDOY < 1 || cDOY > 366) continue;

          yVals[cDOY - 1] = tm;

          const actualDOY = ( (year % 4 === 0) && (year % 100 !== 0 || year % 400 === 0) ) ? cDOY : (cDOY > 60 ? cDOY - 1 : cDOY);
          const iso = isoFromYearAndDoy(year, actualDOY);
          hover[cDOY - 1] = formatDateOrdinal(iso);
        }
        return { yVals, hover };
      }

      const perYear = new Map();
      let gmin = +Infinity, gmax = -Infinity;
      for (const yr of YEARS) {
        const obj = yearSeries(yr);
        perYear.set(yr, obj);
        for (const v of obj.yVals) {
          if (v === null) continue;
          if (v < gmin) gmin = v;
          if (v > gmax) gmax = v;
        }
      }
      if (!isFinite(gmin) || !isFinite(gmax)) {
        document.getElementById("ridge").innerHTML = `<div class="note">No data for 2020–2025.</div>`;
        return;
      }

      const GAP = 30, SCALE = 0.25;
      const traces = [];

      YEARS.forEach((yr, idx) => {
        const baseY = idx * GAP;
        const { yVals, hover } = perYear.get(yr);
        const yRidge = yVals.map(v => (v === null ? null : (v - gmin) * SCALE + baseY));

        let sx = [], sb = [], sr = [], sh = [];
        let legendShown = false;

        const flush = () => {
          if (sx.length === 0) return;

          if (sx.length === 1) {
            const tempAtPoint = yVals[DOY.indexOf(sx[0])];
            traces.push({
              type: "scatter", mode: "markers",
              name: String(yr), showlegend: !legendShown,
              marker: { color: COLORS[idx], size: 5 },
              x: [sx[0]], y: [sr[0]],
              customdata: [[sh[0], tempAtPoint]],
              hovertemplate: "%{customdata[0]}<br>Mean: %{customdata[1]:.1f}°F<extra></extra>"
            });
            legendShown = true;
          } else {
            traces.push({
              type: "scatter", mode: "lines",
              x: sx, y: sb, line: { color: "rgba(0,0,0,0)" }, hoverinfo: "skip", showlegend: false
            });
            traces.push({
              type: "scatter", mode: "lines",
              name: String(yr), showlegend: !legendShown,
              x: sx, y: sr,
              line: { color: COLORS[idx], width: 1.2, shape: "spline" },
              fill: "tonexty", fillcolor: hexToRgba(COLORS[idx], 0.55),
              connectgaps: false,
              customdata: sr.map((_, j) => [sh[j], yVals[DOY.indexOf(sx[j])]]),
              hovertemplate: "%{customdata[0]}<br>Mean: %{customdata[1]:.1f}°F<extra></extra>"
            });
            legendShown = true;
          }
          sx = []; sb = []; sr = []; sh = [];
        };

        for (let j = 0; j < DOY.length; j++) {
          const x = DOY[j], yv = yRidge[j];
          if (yv === null) { flush(); continue; }
          sx.push(x); sb.push(baseY); sr.push(yv); sh.push(hover[j]);
        }
        flush();
      });

      const layout2 = {
        title: { text: "Ridgeline — Daily Mean Temperature by Day‑of‑Year (2020–2025)", x: 0, xanchor: "left" },
        margin: { t: 60, r: 20, b: 40, l: 60 },
        xaxis: { title: "Day of Year", range: [1, 366], tickmode: "array", tickvals: MONTH_TICKS, ticktext: MONTH_TEXT },
        yaxis: { title: "", zeroline: false, showgrid: true,
                 tickmode: "array", tickvals: [0,1,2,3,4,5].map(i=>i*30),
                 ticktext: ["2020","2021","2022","2023","2024","2025"] },
        hovermode: "x unified",
        hoverdistance: 1,
        legend: { orientation: "h", x: 1, y: 1.12, xanchor: "right", yanchor: "bottom" }
      };

      Plotly.newPlot("ridge", traces, layout2, { responsive: true, displaylogo: false });
    }

    // ------------------------------
    // Summary table (Grid.js via CDN)
    // ------------------------------
    const monthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

    function getSelectedMetric() {
      const el = document.querySelector('input[name="metric"]:checked');
      return el ? el.value : "avg_tmax";
    }

    async function loadSummary() {
      const metric = getSelectedMetric();
      const start = Number(document.getElementById("yearStart").value || 2020);
      const end   = Number(document.getElementById("yearEnd").value   || 2025);
      const url = `/api/summary?metric=${encodeURIComponent(metric)}&start=${start}&end=${end}`;
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`Failed to load summary (${resp.status})`);
      return resp.json();
    }

    // Grid.js columns
    const gridColumns = [
      { id: "year", name: "Year", sort: true },
      ...monthNames.map(m => ({
        id: m,
        name: m,
        sort: true,
        formatter: (cell) => {
          if (cell === null || cell === undefined) return "—";
          return Number(cell).toFixed(1);
        }
      }))
    ];

    let grid = null;

    async function renderSummary() {
      try {
        const data = await loadSummary();
        const rows = (data.rows || []).map(row => [row.year, ...monthNames.map(m => row[m])]);

        if (!grid) {
          grid = new gridjs.Grid({
            columns: gridColumns,
            data: rows,
            sort: true,
            search: false,
            pagination: false,
            fixedHeader: true,
            style: { table: { 'font-size': '0.95rem' } }
          });
          grid.render(document.getElementById("summary-grid"));
        } else {
          grid.updateConfig({ data: rows }).forceRender();
        }
      } catch (err) {
        const el = document.getElementById("summary-grid");
        el.innerHTML = `<div style="padding:0.75rem;color:crimson;">
          <strong>Failed to load summary:</strong> ${String(err.message || err)}
        </div>`;
      }
    }

    // Simple CSV download
    function downloadCSV(filename, rows) {
      const headers = ["Year", ...monthNames];
      const lines = [headers.join(",")];
      for (const r of rows) {
        const line = r.map(v => (v === null || v === undefined) ? "" : v).join(",");
        lines.push(line);
      }
      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8;" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename; a.style.display = "none";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    document.getElementById("btnApply").addEventListener("click", renderSummary);
    document.querySelectorAll('input[name="metric"]').forEach(r => r.addEventListener("change", renderSummary));
    document.getElementById("btnDownload").addEventListener("click", async () => {
      const data = await loadSummary();
      const rows = (data.rows || []).map(row => [row.year, ...monthNames.map(m => row[m])]);
      downloadCSV("summary.csv", rows);
    });

    // Initial render
    renderSummary();
  </script>
</body>
</html>
